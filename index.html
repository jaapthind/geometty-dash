<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smash Karts Pro â€“ Ultra Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #a5f3fc; font-family: 'Segoe UI', Arial, sans-serif; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud-text { color: white; text-shadow: 3px 3px 0px #000, 0 0 10px rgba(0,0,0,0.5); font-weight: 900; font-style: italic; }
        #countdown { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 180px; display: none; }
        #stats { position: absolute; top: 20px; left: 20px; font-size: 28px; }
        #speed-o { position: absolute; bottom: 30px; right: 30px; font-size: 50px; color: #facc15; }
        #mini-map { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.3); border: 4px solid white; border-radius: 50%; overflow: hidden; }
        #mobile-joystick { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.2); border-radius: 50%; display: none; pointer-events: auto; }
        @media (max-width: 1024px) { #mobile-joystick { display: block; } }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="stats" class="hud-text">LAP 1/3<br>POS: 4TH</div>
        <div id="countdown" class="hud-text">3</div>
        <div id="speed-o" class="hud-text">000<span>KM/H</span></div>
        <div id="mini-map"></div>
        <div id="mobile-joystick"></div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- WORLD ENGINE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x7dd3fc);
        scene.fog = new THREE.FogExp2(0x7dd3fc, 0.005);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING & ENVIRONMENT ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Create Procedural Terrain (Mountains)
        const groundGeo = new THREE.PlaneGeometry(2000, 2000, 50, 50);
        const groundPos = groundGeo.attributes.position;
        for (let i = 0; i < groundPos.count; i++) {
            const x = groundPos.getX(i);
            const y = groundPos.getY(i);
            if (Math.abs(x) > 150 || Math.abs(y) > 150) {
                groundPos.setZ(i, Math.random() * 40);
            }
        }
        groundGeo.computeVertexNormals();
        const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x4ade80, roughness: 1 }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- THE TRACK (ADVANCED SPLINE) ---
        const trackPoints = [
            new THREE.Vector3(0, 0, 0), new THREE.Vector3(200, 0, 0),
            new THREE.Vector3(350, 0, 150), new THREE.Vector3(300, 0, 400),
            new THREE.Vector3(100, 0, 500), new THREE.Vector3(-200, 0, 400),
            new THREE.Vector3(-300, 0, 100), new THREE.Vector3(-150, 0, -50),
            new THREE.Vector3(0, 0, 0)
        ];
        const curve = new THREE.CatmullRomCurve3(trackPoints);
        const tubeGeo = new THREE.TubeGeometry(curve, 200, 15, 12, true);
        const tubeMat = new THREE.MeshStandardMaterial({ color: 0x334155, roughness: 0.6 });
        const road = new THREE.Mesh(tubeGeo, tubeMat);
        road.position.y = -0.5;
        road.receiveShadow = true;
        scene.add(road);

        // --- KART PHYSICS & CLASS ---
        class Kart {
            constructor(color, isPlayer = false) {
                this.group = new THREE.Group();
                this.isPlayer = isPlayer;
                this.speed = 0;
                this.angle = 0;
                this.progress = 0;
                this.drift = 0;

                // Detailed Body Build
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 4.5), new THREE.MeshStandardMaterial({ color }));
                body.castShadow = true;
                this.group.add(body);

                // Engine & Exhaust
                const engine = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.2, 1.5), new THREE.MeshStandardMaterial({ color: 0x1e293b }));
                engine.position.set(0, 0.6, -1.8);
                this.group.add(engine);

                // Driver Seat
                const seat = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                seat.position.set(0, 0.4, 0);
                this.group.add(seat);

                scene.add(this.group);
            }

            update(keys) {
                if (this.isPlayer) {
                    if (keys['ArrowUp'] || keys['KeyW']) this.speed += 0.08;
                    if (keys['ArrowDown'] || keys['KeyS']) this.speed -= 0.06;
                    if (keys['ArrowLeft'] || keys['KeyA']) this.angle += 0.05 * (Math.min(this.speed, 1));
                    if (keys['ArrowRight'] || keys['KeyD']) this.angle -= 0.05 * (Math.min(this.speed, 1));
                    
                    this.speed *= 0.97; // Drag
                    this.group.position.x += Math.sin(this.angle) * this.speed;
                    this.group.position.z += Math.cos(this.angle) * this.speed;
                    this.group.rotation.y = this.angle;
                } else {
                    // Bot AI Waypoint Following
                    this.progress += 0.0008;
                    const pos = curve.getPointAt(this.progress % 1);
                    this.group.position.copy(pos);
                    this.group.lookAt(curve.getPointAt((this.progress + 0.01) % 1));
                }
            }
        }

        const player = new Kart(0xef4444, true);
        const bots = [new Kart(0x3b82f6), new Kart(0xf59e0b), new Kart(0x8b5cf6)];

        // --- GAME LOGIC ---
        let gameStarted = false;
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        function startCountdown() {
            const countEl = document.getElementById('countdown');
            countEl.style.display = 'block';
            let count = 3;
            const interval = setInterval(() => {
                count--;
                countEl.innerText = count > 0 ? count : "GO!";
                if (count < 0) {
                    clearInterval(interval);
                    countEl.style.display = 'none';
                    gameStarted = true;
                }
            }, 1000);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (gameStarted) {
                player.update(keys);
                bots.forEach(bot => bot.update());

                // Smooth Camera Follow with Lerp
                const cameraOffset = new THREE.Vector3(0, 6, -18).applyQuaternion(player.group.quaternion);
                camera.position.lerp(player.group.position.clone().add(cameraOffset), 0.1);
                camera.lookAt(player.group.position);

                document.getElementById('speed-o').innerHTML = `${Math.floor(player.speed * 150)}<span>KM/H</span>`;
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        startCountdown();
        animate();
    </script>
</body>
</html>
